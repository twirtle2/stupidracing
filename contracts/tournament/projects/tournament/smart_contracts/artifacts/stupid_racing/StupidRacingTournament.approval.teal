#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 8 2
    bytecblock "state" "bracket_size" 0x151f7c75 "admin" "registered_count" "s" "m" "t" "season" "beacon_app_id" "vrf_commit_round" "champion"
    // smart_contracts/stupid_racing/contract.algo.ts:60
    // export class StupidRacingTournament extends arc4.Contract {
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    bz main_create_NoOp@13
    pushbytess 0x18db4b62 0x4f1247da 0xa3226c92 0xb8b61416 0x0c443577 0x03284fed 0xc32082f6 0xfdbcc9eb 0x4cab179a // method "openRegistration()void", method "registerTeam(uint64,uint64,uint64,uint64,uint64)void", method "closeTournament()void", method "getTeam(address)(uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "getSlot(uint64)address", method "getTournamentInfo()(uint64,uint64,uint64,uint64)", method "getMatchResult(uint64)(address,address,address,uint64,uint64,byte[])", method "runMatch(uint64,uint64)void", method "getChampion()address"
    txna ApplicationArgs 0
    match openRegistration registerTeam closeTournament getTeam getSlot getTournamentInfo getMatchResult runMatch getChampion
    err

main_create_NoOp@13:
    // smart_contracts/stupid_racing/contract.algo.ts:60
    // export class StupidRacingTournament extends arc4.Contract {
    pushbytes 0x7efda4d2 // method "create(uint64,uint64,uint64)void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.create[routing]() -> void:
create:
    // smart_contracts/stupid_racing/contract.algo.ts:73
    // @abimethod({ onCreate: 'require' })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    swap
    // smart_contracts/stupid_racing/contract.algo.ts:80
    // bracketSize === Uint64(2) ||
    intc_3 // 2
    ==
    // smart_contracts/stupid_racing/contract.algo.ts:80-81
    // bracketSize === Uint64(2) ||
    // bracketSize === Uint64(4) ||
    bnz create_bool_true@7
    // smart_contracts/stupid_racing/contract.algo.ts:81
    // bracketSize === Uint64(4) ||
    dig 1
    pushint 4 // 4
    ==
    // smart_contracts/stupid_racing/contract.algo.ts:80-81
    // bracketSize === Uint64(2) ||
    // bracketSize === Uint64(4) ||
    bnz create_bool_true@7
    // smart_contracts/stupid_racing/contract.algo.ts:82
    // bracketSize === Uint64(8) ||
    dig 1
    intc_2 // 8
    ==
    // smart_contracts/stupid_racing/contract.algo.ts:80-82
    // bracketSize === Uint64(2) ||
    // bracketSize === Uint64(4) ||
    // bracketSize === Uint64(8) ||
    bnz create_bool_true@7
    // smart_contracts/stupid_racing/contract.algo.ts:83
    // bracketSize === Uint64(16) ||
    dig 1
    pushint 16 // 16
    ==
    // smart_contracts/stupid_racing/contract.algo.ts:80-83
    // bracketSize === Uint64(2) ||
    // bracketSize === Uint64(4) ||
    // bracketSize === Uint64(8) ||
    // bracketSize === Uint64(16) ||
    bnz create_bool_true@7
    // smart_contracts/stupid_racing/contract.algo.ts:84
    // bracketSize === Uint64(32) ||
    dig 1
    pushint 32 // 32
    ==
    // smart_contracts/stupid_racing/contract.algo.ts:80-84
    // bracketSize === Uint64(2) ||
    // bracketSize === Uint64(4) ||
    // bracketSize === Uint64(8) ||
    // bracketSize === Uint64(16) ||
    // bracketSize === Uint64(32) ||
    bnz create_bool_true@7
    // smart_contracts/stupid_racing/contract.algo.ts:85
    // bracketSize === Uint64(64),
    dig 1
    pushint 64 // 64
    ==
    // smart_contracts/stupid_racing/contract.algo.ts:80-85
    // bracketSize === Uint64(2) ||
    // bracketSize === Uint64(4) ||
    // bracketSize === Uint64(8) ||
    // bracketSize === Uint64(16) ||
    // bracketSize === Uint64(32) ||
    // bracketSize === Uint64(64),
    bz create_bool_false@8

create_bool_true@7:
    intc_1 // 1

create_bool_merge@9:
    // smart_contracts/stupid_racing/contract.algo.ts:79-87
    // assert(
    //     bracketSize === Uint64(2) ||
    //     bracketSize === Uint64(4) ||
    //     bracketSize === Uint64(8) ||
    //     bracketSize === Uint64(16) ||
    //     bracketSize === Uint64(32) ||
    //     bracketSize === Uint64(64),
    //     'Bracket size must be 2, 4, 8, 16, 32, or 64'
    // )
    assert // Bracket size must be 2, 4, 8, 16, 32, or 64
    // smart_contracts/stupid_racing/contract.algo.ts:62
    // season = GlobalState<uint64>({ key: Bytes`season` })
    bytec 8 // "season"
    // smart_contracts/stupid_racing/contract.algo.ts:89
    // this.season.value = season
    dig 3
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:63
    // bracketSize = GlobalState<uint64>({ key: Bytes`bracket_size` })
    bytec_1 // "bracket_size"
    // smart_contracts/stupid_racing/contract.algo.ts:90
    // this.bracketSize.value = bracketSize
    dig 2
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:61
    // beaconAppId = GlobalState<uint64>({ key: Bytes`beacon_app_id` })
    bytec 9 // "beacon_app_id"
    // smart_contracts/stupid_racing/contract.algo.ts:91
    // this.beaconAppId.value = beaconAppId
    dig 1
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:64
    // admin = GlobalState<AccountType>({ key: Bytes`admin` })
    bytec_3 // "admin"
    // smart_contracts/stupid_racing/contract.algo.ts:92
    // this.admin.value = Txn.sender
    txn Sender
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:93
    // this.state.value = STATE_CREATED
    intc_0 // 0
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:66
    // registeredCount = GlobalState<uint64>({ key: Bytes`registered_count` })
    bytec 4 // "registered_count"
    // smart_contracts/stupid_racing/contract.algo.ts:94
    // this.registeredCount.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:73
    // @abimethod({ onCreate: 'require' })
    intc_1 // 1
    return

create_bool_false@8:
    intc_0 // 0
    b create_bool_merge@9


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.openRegistration[routing]() -> void:
openRegistration:
    // smart_contracts/stupid_racing/contract.algo.ts:99
    // assert(Txn.sender === this.admin.value, 'Only admin can open registration')
    txn Sender
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:64
    // admin = GlobalState<AccountType>({ key: Bytes`admin` })
    bytec_3 // "admin"
    // smart_contracts/stupid_racing/contract.algo.ts:99
    // assert(Txn.sender === this.admin.value, 'Only admin can open registration')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only admin can open registration
    // smart_contracts/stupid_racing/contract.algo.ts:100
    // assert(this.state.value === STATE_CREATED, 'Tournament must be in created state')
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:100
    // assert(this.state.value === STATE_CREATED, 'Tournament must be in created state')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Tournament must be in created state
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:101
    // this.state.value = STATE_REGISTRATION_OPEN
    intc_1 // 1
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:97
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.registerTeam[routing]() -> void:
registerTeam:
    // smart_contracts/stupid_racing/contract.algo.ts:104
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 3
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 4
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 5
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/stupid_racing/contract.algo.ts:112
    // assert(this.state.value === STATE_REGISTRATION_OPEN, 'Registration is not open')
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:112
    // assert(this.state.value === STATE_REGISTRATION_OPEN, 'Registration is not open')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // Registration is not open
    // smart_contracts/stupid_racing/contract.algo.ts:69
    // teams = BoxMap<AccountType, TeamRegistration>({ keyPrefix: Bytes`t` })
    bytec 7 // "t"
    // smart_contracts/stupid_racing/contract.algo.ts:113
    // assert(!this.teams(Txn.sender).exists, 'Team already registered')
    txn Sender
    // smart_contracts/stupid_racing/contract.algo.ts:69
    // teams = BoxMap<AccountType, TeamRegistration>({ keyPrefix: Bytes`t` })
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:113
    // assert(!this.teams(Txn.sender).exists, 'Team already registered')
    box_len
    bury 1
    !
    assert // Team already registered
    // smart_contracts/stupid_racing/contract.algo.ts:344
    // assert(assetId0 > Uint64(0), 'Asset ID must be positive')
    dig 4
    assert // Asset ID must be positive
    // smart_contracts/stupid_racing/contract.algo.ts:345
    // assert(assetId1 > Uint64(0), 'Asset ID must be positive')
    dig 3
    assert // Asset ID must be positive
    // smart_contracts/stupid_racing/contract.algo.ts:346
    // assert(assetId2 > Uint64(0), 'Asset ID must be positive')
    dig 2
    assert // Asset ID must be positive
    // smart_contracts/stupid_racing/contract.algo.ts:347
    // assert(assetId3 > Uint64(0), 'Asset ID must be positive')
    dig 1
    assert // Asset ID must be positive
    // smart_contracts/stupid_racing/contract.algo.ts:348
    // assert(assetId4 > Uint64(0), 'Asset ID must be positive')
    dup
    assert // Asset ID must be positive
    // smart_contracts/stupid_racing/contract.algo.ts:349
    // assert(assetId0 !== assetId1, 'Team assets must be unique')
    dig 4
    dig 4
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:350
    // assert(assetId0 !== assetId2, 'Team assets must be unique')
    dig 4
    dig 3
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:351
    // assert(assetId0 !== assetId3, 'Team assets must be unique')
    dig 4
    dig 2
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:352
    // assert(assetId0 !== assetId4, 'Team assets must be unique')
    dig 4
    dig 1
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:353
    // assert(assetId1 !== assetId2, 'Team assets must be unique')
    dig 3
    dig 3
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:354
    // assert(assetId1 !== assetId3, 'Team assets must be unique')
    dig 3
    dig 2
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:355
    // assert(assetId1 !== assetId4, 'Team assets must be unique')
    dig 3
    dig 1
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:356
    // assert(assetId2 !== assetId3, 'Team assets must be unique')
    dig 2
    dig 2
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:357
    // assert(assetId2 !== assetId4, 'Team assets must be unique')
    dig 2
    dig 1
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:358
    // assert(assetId3 !== assetId4, 'Team assets must be unique')
    dup2
    !=
    assert // Team assets must be unique
    // smart_contracts/stupid_racing/contract.algo.ts:115
    // this.assertOwnedAllowedAsset(assetId0)
    dig 4
    callsub assertOwnedAllowedAsset
    // smart_contracts/stupid_racing/contract.algo.ts:116
    // this.assertOwnedAllowedAsset(assetId1)
    dig 3
    callsub assertOwnedAllowedAsset
    // smart_contracts/stupid_racing/contract.algo.ts:117
    // this.assertOwnedAllowedAsset(assetId2)
    dig 2
    callsub assertOwnedAllowedAsset
    // smart_contracts/stupid_racing/contract.algo.ts:118
    // this.assertOwnedAllowedAsset(assetId3)
    dig 1
    callsub assertOwnedAllowedAsset
    // smart_contracts/stupid_racing/contract.algo.ts:119
    // this.assertOwnedAllowedAsset(assetId4)
    dup
    callsub assertOwnedAllowedAsset
    // smart_contracts/stupid_racing/contract.algo.ts:121
    // const currentCount: uint64 = this.registeredCount.value
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:66
    // registeredCount = GlobalState<uint64>({ key: Bytes`registered_count` })
    bytec 4 // "registered_count"
    // smart_contracts/stupid_racing/contract.algo.ts:121
    // const currentCount: uint64 = this.registeredCount.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:122
    // assert(currentCount < this.bracketSize.value, 'Bracket is full')
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:63
    // bracketSize = GlobalState<uint64>({ key: Bytes`bracket_size` })
    bytec_1 // "bracket_size"
    // smart_contracts/stupid_racing/contract.algo.ts:122
    // assert(currentCount < this.bracketSize.value, 'Bracket is full')
    app_global_get_ex
    assert // check GlobalState exists
    dig 1
    >
    assert // Bracket is full
    // smart_contracts/stupid_racing/contract.algo.ts:131
    // registeredAt: Global.latestTimestamp,
    global LatestTimestamp
    // smart_contracts/stupid_racing/contract.algo.ts:124-132
    // const team: TeamRegistration = {
    //     assetId0: assetId0,
    //     assetId1: assetId1,
    //     assetId2: assetId2,
    //     assetId3: assetId3,
    //     assetId4: assetId4,
    //     slotIndex: currentCount,
    //     registeredAt: Global.latestTimestamp,
    // }
    uncover 6
    itob
    uncover 6
    itob
    concat
    uncover 5
    itob
    concat
    uncover 4
    itob
    concat
    uncover 3
    itob
    concat
    dig 2
    itob
    swap
    dig 1
    concat
    uncover 2
    itob
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:69
    // teams = BoxMap<AccountType, TeamRegistration>({ keyPrefix: Bytes`t` })
    bytec 7 // "t"
    // smart_contracts/stupid_racing/contract.algo.ts:134
    // this.teams(Txn.sender).value = clone(team)
    txn Sender
    // smart_contracts/stupid_racing/contract.algo.ts:69
    // teams = BoxMap<AccountType, TeamRegistration>({ keyPrefix: Bytes`t` })
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:134
    // this.teams(Txn.sender).value = clone(team)
    swap
    box_put
    // smart_contracts/stupid_racing/contract.algo.ts:135
    // this.bracketSlots(currentCount).value = Txn.sender
    txn Sender
    // smart_contracts/stupid_racing/contract.algo.ts:70
    // bracketSlots = BoxMap<uint64, AccountType>({ keyPrefix: Bytes`s` })
    bytec 5 // "s"
    uncover 2
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:135
    // this.bracketSlots(currentCount).value = Txn.sender
    swap
    box_put
    // smart_contracts/stupid_racing/contract.algo.ts:136
    // this.registeredCount.value = currentCount + Uint64(1)
    intc_1 // 1
    +
    // smart_contracts/stupid_racing/contract.algo.ts:66
    // registeredCount = GlobalState<uint64>({ key: Bytes`registered_count` })
    bytec 4 // "registered_count"
    // smart_contracts/stupid_racing/contract.algo.ts:136
    // this.registeredCount.value = currentCount + Uint64(1)
    dig 1
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:138
    // if (this.registeredCount.value === this.bracketSize.value) {
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:63
    // bracketSize = GlobalState<uint64>({ key: Bytes`bracket_size` })
    bytec_1 // "bracket_size"
    // smart_contracts/stupid_racing/contract.algo.ts:138
    // if (this.registeredCount.value === this.bracketSize.value) {
    app_global_get_ex
    assert // check GlobalState exists
    ==
    bz registerTeam_after_if_else@3
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:144
    // this.state.value = STATE_LOCKED
    intc_3 // 2
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:145
    // this.vrfCommitRound.value = Global.round + Uint64(16)
    global Round
    pushint 16 // 16
    +
    // smart_contracts/stupid_racing/contract.algo.ts:67
    // vrfCommitRound = GlobalState<uint64>({ key: Bytes`vrf_commit_round` })
    bytec 10 // "vrf_commit_round"
    // smart_contracts/stupid_racing/contract.algo.ts:145
    // this.vrfCommitRound.value = Global.round + Uint64(16)
    swap
    app_global_put

registerTeam_after_if_else@3:
    // smart_contracts/stupid_racing/contract.algo.ts:104
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.closeTournament[routing]() -> void:
closeTournament:
    // smart_contracts/stupid_racing/contract.algo.ts:150
    // assert(Txn.sender === this.admin.value, 'Only admin can close tournament')
    txn Sender
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:64
    // admin = GlobalState<AccountType>({ key: Bytes`admin` })
    bytec_3 // "admin"
    // smart_contracts/stupid_racing/contract.algo.ts:150
    // assert(Txn.sender === this.admin.value, 'Only admin can close tournament')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only admin can close tournament
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:151
    // this.state.value = STATE_CANCELLED
    pushint 5 // 5
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:148
    // @abimethod()
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.getTeam[routing]() -> void:
getTeam:
    // smart_contracts/stupid_racing/contract.algo.ts:154
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    pushint 32 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/stupid_racing/contract.algo.ts:69
    // teams = BoxMap<AccountType, TeamRegistration>({ keyPrefix: Bytes`t` })
    bytec 7 // "t"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:156
    // assert(this.teams(wallet).exists, 'Team not registered')
    dup
    box_len
    bury 1
    assert // Team not registered
    // smart_contracts/stupid_racing/contract.algo.ts:157
    // return clone(this.teams(wallet).value)
    box_get
    pop
    // smart_contracts/stupid_racing/contract.algo.ts:154
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.getSlot[routing]() -> void:
getSlot:
    // smart_contracts/stupid_racing/contract.algo.ts:160
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/stupid_racing/contract.algo.ts:162
    // assert(this.bracketSlots(slotIndex).exists, 'Slot is empty')
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:70
    // bracketSlots = BoxMap<uint64, AccountType>({ keyPrefix: Bytes`s` })
    bytec 5 // "s"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:162
    // assert(this.bracketSlots(slotIndex).exists, 'Slot is empty')
    dup
    box_len
    bury 1
    assert // Slot is empty
    // smart_contracts/stupid_racing/contract.algo.ts:163
    // return this.bracketSlots(slotIndex).value
    box_get
    pop
    // smart_contracts/stupid_racing/contract.algo.ts:160
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.getTournamentInfo[routing]() -> void:
getTournamentInfo:
    // smart_contracts/stupid_racing/contract.algo.ts:174
    // season: this.season.value,
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:62
    // season = GlobalState<uint64>({ key: Bytes`season` })
    bytec 8 // "season"
    // smart_contracts/stupid_racing/contract.algo.ts:174
    // season: this.season.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:175
    // bracketSize: this.bracketSize.value,
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:63
    // bracketSize = GlobalState<uint64>({ key: Bytes`bracket_size` })
    bytec_1 // "bracket_size"
    // smart_contracts/stupid_racing/contract.algo.ts:175
    // bracketSize: this.bracketSize.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:176
    // registeredCount: this.registeredCount.value,
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:66
    // registeredCount = GlobalState<uint64>({ key: Bytes`registered_count` })
    bytec 4 // "registered_count"
    // smart_contracts/stupid_racing/contract.algo.ts:176
    // registeredCount: this.registeredCount.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:177
    // state: this.state.value,
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:177
    // state: this.state.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:173-178
    // return {
    //     season: this.season.value,
    //     bracketSize: this.bracketSize.value,
    //     registeredCount: this.registeredCount.value,
    //     state: this.state.value,
    // }
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:166
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.getMatchResult[routing]() -> void:
getMatchResult:
    // smart_contracts/stupid_racing/contract.algo.ts:181
    // @abimethod({ readonly: true })
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/stupid_racing/contract.algo.ts:183
    // assert(this.matchResults(matchId).exists, 'Match result not found')
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:71
    // matchResults = BoxMap<uint64, MatchResult>({ keyPrefix: Bytes`m` })
    bytec 6 // "m"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:183
    // assert(this.matchResults(matchId).exists, 'Match result not found')
    dup
    box_len
    bury 1
    assert // Match result not found
    // smart_contracts/stupid_racing/contract.algo.ts:184
    // return clone(this.matchResults(matchId).value)
    box_get
    pop
    // smart_contracts/stupid_racing/contract.algo.ts:181
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.runMatch[routing]() -> void:
runMatch:
    intc_0 // 0
    dupn 6
    pushbytes ""
    dupn 15
    // smart_contracts/stupid_racing/contract.algo.ts:187
    // @abimethod()
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    txna ApplicationArgs 2
    dup
    len
    intc_2 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/stupid_racing/contract.algo.ts:189
    // assert(Txn.sender === this.admin.value, 'Only admin can run matches')
    txn Sender
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:64
    // admin = GlobalState<AccountType>({ key: Bytes`admin` })
    bytec_3 // "admin"
    // smart_contracts/stupid_racing/contract.algo.ts:189
    // assert(Txn.sender === this.admin.value, 'Only admin can run matches')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only admin can run matches
    // smart_contracts/stupid_racing/contract.algo.ts:191
    // this.state.value === STATE_LOCKED || this.state.value === STATE_RACING,
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:191
    // this.state.value === STATE_LOCKED || this.state.value === STATE_RACING,
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 2
    ==
    bnz runMatch_bool_true@3
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:191
    // this.state.value === STATE_LOCKED || this.state.value === STATE_RACING,
    app_global_get_ex
    assert // check GlobalState exists
    pushint 3 // 3
    ==
    bz runMatch_bool_false@4

runMatch_bool_true@3:
    intc_1 // 1

runMatch_bool_merge@5:
    // smart_contracts/stupid_racing/contract.algo.ts:190-193
    // assert(
    //     this.state.value === STATE_LOCKED || this.state.value === STATE_RACING,
    //     'Tournament not ready'
    // )
    assert // Tournament not ready
    // smart_contracts/stupid_racing/contract.algo.ts:194
    // assert(Global.round >= this.vrfCommitRound.value, 'VRF round not reached')
    global Round
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:67
    // vrfCommitRound = GlobalState<uint64>({ key: Bytes`vrf_commit_round` })
    bytec 10 // "vrf_commit_round"
    // smart_contracts/stupid_racing/contract.algo.ts:194
    // assert(Global.round >= this.vrfCommitRound.value, 'VRF round not reached')
    app_global_get_ex
    assert // check GlobalState exists
    swap
    dig 1
    >=
    assert // VRF round not reached
    // smart_contracts/stupid_racing/contract.algo.ts:195
    // assert(Txn.fee >= Global.minTxnFee + Global.minTxnFee, 'Insufficient fee pooling for beacon call')
    txn Fee
    global MinTxnFee
    dup
    +
    >=
    assert // Insufficient fee pooling for beacon call
    // smart_contracts/stupid_racing/contract.algo.ts:197
    // const matchId: uint64 = roundIndex * Uint64(100) + matchIndex
    dig 2
    dup
    cover 2
    pushint 100 // 100
    *
    dig 3
    +
    // smart_contracts/stupid_racing/contract.algo.ts:198
    // assert(!this.matchResults(matchId).exists, 'Match already played')
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:71
    // matchResults = BoxMap<uint64, MatchResult>({ keyPrefix: Bytes`m` })
    bytec 6 // "m"
    dig 1
    concat
    dup
    bury 29
    // smart_contracts/stupid_racing/contract.algo.ts:198
    // assert(!this.matchResults(matchId).exists, 'Match already played')
    box_len
    bury 1
    !
    assert // Match already played
    // smart_contracts/stupid_racing/contract.algo.ts:204
    // const saltLenPrefix = op.extract(saltLenBytes, Uint64(6), Uint64(2))
    pushbytes 0x0008
    // smart_contracts/stupid_racing/contract.algo.ts:205
    // const encodedSalt = op.concat(saltLenPrefix, matchSalt)
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:207-215
    // const result = itxn.applicationCall({
    //     appId: this.beaconAppId.value,
    //     appArgs: [
    //         arc4.methodSelector('must_get(uint64,byte[])byte[]'),
    //         op.itob(this.vrfCommitRound.value), // uint64 is just 8 bytes in ARC-4
    //         encodedSalt
    //     ],
    //     fee: Uint64(0), // Fee pooling expected
    // }).submit()
    itxn_begin
    // smart_contracts/stupid_racing/contract.algo.ts:208
    // appId: this.beaconAppId.value,
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:61
    // beaconAppId = GlobalState<uint64>({ key: Bytes`beacon_app_id` })
    bytec 9 // "beacon_app_id"
    // smart_contracts/stupid_racing/contract.algo.ts:208
    // appId: this.beaconAppId.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:211
    // op.itob(this.vrfCommitRound.value), // uint64 is just 8 bytes in ARC-4
    uncover 2
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:210
    // arc4.methodSelector('must_get(uint64,byte[])byte[]'),
    pushbytes 0x47c20c23 // method "must_get(uint64,byte[])byte[]"
    itxn_field ApplicationArgs
    itxn_field ApplicationArgs
    itxn_field ApplicationID
    itxn_field ApplicationArgs
    // smart_contracts/stupid_racing/contract.algo.ts:207-215
    // const result = itxn.applicationCall({
    //     appId: this.beaconAppId.value,
    //     appArgs: [
    //         arc4.methodSelector('must_get(uint64,byte[])byte[]'),
    //         op.itob(this.vrfCommitRound.value), // uint64 is just 8 bytes in ARC-4
    //         encodedSalt
    //     ],
    //     fee: Uint64(0), // Fee pooling expected
    // }).submit()
    pushint 6 // 6
    itxn_field TypeEnum
    // smart_contracts/stupid_racing/contract.algo.ts:214
    // fee: Uint64(0), // Fee pooling expected
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/stupid_racing/contract.algo.ts:207-215
    // const result = itxn.applicationCall({
    //     appId: this.beaconAppId.value,
    //     appArgs: [
    //         arc4.methodSelector('must_get(uint64,byte[])byte[]'),
    //         op.itob(this.vrfCommitRound.value), // uint64 is just 8 bytes in ARC-4
    //         encodedSalt
    //     ],
    //     fee: Uint64(0), // Fee pooling expected
    // }).submit()
    itxn_submit
    itxn LastLog
    // smart_contracts/stupid_racing/contract.algo.ts:220
    // const vrfOutput = op.extract(rawLog, Uint64(6), Uint64(32))
    extract 6 32
    bury 20
    // smart_contracts/stupid_racing/contract.algo.ts:226
    // if (roundIndex === Uint64(0)) {
    bnz runMatch_else_body@8
    // smart_contracts/stupid_racing/contract.algo.ts:227
    // leftWallet = this.bracketSlots(matchIndex * Uint64(2)).value
    dup
    intc_3 // 2
    *
    dup
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:70
    // bracketSlots = BoxMap<uint64, AccountType>({ keyPrefix: Bytes`s` })
    bytec 5 // "s"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:227
    // leftWallet = this.bracketSlots(matchIndex * Uint64(2)).value
    box_get
    swap
    bury 24
    assert // Box must have value
    // smart_contracts/stupid_racing/contract.algo.ts:228
    // rightWallet = this.bracketSlots(matchIndex * Uint64(2) + Uint64(1)).value
    intc_1 // 1
    +
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:70
    // bracketSlots = BoxMap<uint64, AccountType>({ keyPrefix: Bytes`s` })
    bytec 5 // "s"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:228
    // rightWallet = this.bracketSlots(matchIndex * Uint64(2) + Uint64(1)).value
    box_get
    swap
    bury 21
    assert // Box must have value

runMatch_after_if_else@9:
    // smart_contracts/stupid_racing/contract.algo.ts:261
    // let leftWins: uint64 = Uint64(0)
    intc_0 // 0
    bury 13
    // smart_contracts/stupid_racing/contract.algo.ts:262
    // let rightWins: uint64 = Uint64(0)
    intc_0 // 0
    bury 7
    // smart_contracts/stupid_racing/contract.algo.ts:265
    // for (let i = Uint64(0); i < Uint64(5); i = i + Uint64(1)) {
    intc_0 // 0
    bury 18
    dig 18
    bury 24

runMatch_while_top@29:
    // smart_contracts/stupid_racing/contract.algo.ts:265
    // for (let i = Uint64(0); i < Uint64(5); i = i + Uint64(1)) {
    dig 17
    pushint 5 // 5
    <
    bz runMatch_after_while@80
    // smart_contracts/stupid_racing/contract.algo.ts:266
    // const heatRand = op.sha256(currentSeed)
    dig 23
    sha256
    bury 23
    // smart_contracts/stupid_racing/contract.algo.ts:284
    // let leftPos = START_POS
    pushint 50 // 50
    bury 14
    // smart_contracts/stupid_racing/contract.algo.ts:285
    // let rightPos = START_POS
    pushint 50 // 50
    bury 8
    // smart_contracts/stupid_racing/contract.algo.ts:286
    // let status = Uint64(0) // 0=running/draw
    intc_0 // 0
    bury 5
    // smart_contracts/stupid_racing/contract.algo.ts:289
    // for (let step = Uint64(0); step < Uint64(16); step = step + Uint64(1)) {
    intc_0 // 0
    bury 4

runMatch_while_top@31:
    // smart_contracts/stupid_racing/contract.algo.ts:289
    // for (let step = Uint64(0); step < Uint64(16); step = step + Uint64(1)) {
    dig 3
    pushint 16 // 16
    <
    bz runMatch_block@74
    // smart_contracts/stupid_racing/contract.algo.ts:290
    // const leftByte: uint64 = op.getByte(randomness, step * Uint64(2))
    dig 3
    intc_3 // 2
    *
    dig 23
    dup
    cover 2
    dig 1
    getbyte
    // smart_contracts/stupid_racing/contract.algo.ts:291
    // const rightByte: uint64 = op.getByte(randomness, step * Uint64(2) + Uint64(1))
    swap
    intc_1 // 1
    +
    uncover 2
    swap
    getbyte
    bury 12
    // smart_contracts/stupid_racing/contract.algo.ts:294
    // const lMod: uint64 = leftByte % Uint64(5)
    pushint 5 // 5
    %
    dup
    bury 18
    // smart_contracts/stupid_racing/contract.algo.ts:295
    // if (lMod === Uint64(0)) leftPos = leftPos - Uint64(5)
    bnz runMatch_else_body@34
    dig 13
    pushint 5 // 5
    -
    bury 14

runMatch_after_if_else@46:
    // smart_contracts/stupid_racing/contract.algo.ts:301
    // const rMod: uint64 = rightByte % Uint64(5)
    dig 10
    pushint 5 // 5
    %
    dup
    bury 13
    // smart_contracts/stupid_racing/contract.algo.ts:302
    // if (rMod === Uint64(0)) rightPos = rightPos - Uint64(5)
    bnz runMatch_else_body@48
    dig 7
    pushint 5 // 5
    -
    bury 8

runMatch_after_if_else@60:
    // smart_contracts/stupid_racing/contract.algo.ts:308
    // const leftFinish = leftPos >= FINISH_THRESHOLD
    dig 13
    dup
    pushint 71 // 71
    >=
    dup
    cover 2
    bury 17
    // smart_contracts/stupid_racing/contract.algo.ts:309
    // const rightFinish = rightPos >= FINISH_THRESHOLD
    dig 9
    dup
    cover 2
    pushint 71 // 71
    >=
    bury 12
    // smart_contracts/stupid_racing/contract.algo.ts:310
    // const leftCliff = leftPos <= CLIFF_THRESHOLD
    pushint 50 // 50
    <=
    bury 18
    // smart_contracts/stupid_racing/contract.algo.ts:311
    // const rightCliff = rightPos <= CLIFF_THRESHOLD
    pushint 50 // 50
    <=
    bury 11
    // smart_contracts/stupid_racing/contract.algo.ts:313
    // if (leftFinish && rightFinish) { status = Uint64(0); break } // Draw (tie)
    bz runMatch_after_if_else@63
    dig 8
    bz runMatch_after_if_else@63
    intc_0 // 0
    bury 5

runMatch_block@74:
    // smart_contracts/stupid_racing/contract.algo.ts:268
    // if (outcome === Uint64(1)) leftWins = leftWins + Uint64(1)
    dig 4
    intc_1 // 1
    ==
    bz runMatch_else_body@76
    dig 12
    intc_1 // 1
    +
    bury 13

runMatch_after_if_else@79:
    // smart_contracts/stupid_racing/contract.algo.ts:265
    // for (let i = Uint64(0); i < Uint64(5); i = i + Uint64(1)) {
    dig 17
    intc_1 // 1
    +
    bury 18
    dig 22
    bury 24
    b runMatch_while_top@29

runMatch_else_body@76:
    // smart_contracts/stupid_racing/contract.algo.ts:269
    // else if (outcome === Uint64(2)) rightWins = rightWins + Uint64(1)
    dig 4
    intc_3 // 2
    ==
    bz runMatch_after_if_else@79
    dig 6
    intc_1 // 1
    +
    bury 7
    b runMatch_after_if_else@79

runMatch_after_if_else@63:
    // smart_contracts/stupid_racing/contract.algo.ts:314
    // if (leftCliff && rightCliff) { status = Uint64(0); break } // Draw (both dead)
    dig 15
    bz runMatch_after_if_else@66
    dig 9
    bz runMatch_after_if_else@66
    intc_0 // 0
    bury 5
    b runMatch_block@74

runMatch_after_if_else@66:
    // smart_contracts/stupid_racing/contract.algo.ts:315
    // if (leftFinish || rightCliff) { status = Uint64(1); break } // Left wins
    dig 14
    bnz runMatch_if_body@68
    dig 9
    bz runMatch_after_if_else@69

runMatch_if_body@68:
    // smart_contracts/stupid_racing/contract.algo.ts:315
    // if (leftFinish || rightCliff) { status = Uint64(1); break } // Left wins
    intc_1 // 1
    bury 5
    b runMatch_block@74

runMatch_after_if_else@69:
    // smart_contracts/stupid_racing/contract.algo.ts:316
    // if (rightFinish || leftCliff) { status = Uint64(2); break } // Right wins
    dig 8
    bnz runMatch_if_body@71
    dig 15
    bz runMatch_after_if_else@72

runMatch_if_body@71:
    // smart_contracts/stupid_racing/contract.algo.ts:316
    // if (rightFinish || leftCliff) { status = Uint64(2); break } // Right wins
    intc_3 // 2
    bury 5
    b runMatch_block@74

runMatch_after_if_else@72:
    // smart_contracts/stupid_racing/contract.algo.ts:289
    // for (let step = Uint64(0); step < Uint64(16); step = step + Uint64(1)) {
    dig 3
    intc_1 // 1
    +
    bury 4
    b runMatch_while_top@31

runMatch_else_body@48:
    // smart_contracts/stupid_racing/contract.algo.ts:303
    // else if (rMod === Uint64(1)) rightPos = rightPos - Uint64(3)
    dig 11
    intc_1 // 1
    ==
    bz runMatch_else_body@50
    dig 7
    pushint 3 // 3
    -
    bury 8
    b runMatch_after_if_else@60

runMatch_else_body@50:
    // smart_contracts/stupid_racing/contract.algo.ts:304
    // else if (rMod === Uint64(2)) rightPos = rightPos - Uint64(1)
    dig 11
    intc_3 // 2
    ==
    bz runMatch_else_body@52
    dig 7
    intc_1 // 1
    -
    bury 8
    b runMatch_after_if_else@60

runMatch_else_body@52:
    // smart_contracts/stupid_racing/contract.algo.ts:305
    // else if (rMod === Uint64(3)) rightPos = rightPos + Uint64(3)
    dig 11
    pushint 3 // 3
    ==
    bz runMatch_else_body@54
    dig 7
    pushint 3 // 3
    +
    bury 8
    b runMatch_after_if_else@60

runMatch_else_body@54:
    // smart_contracts/stupid_racing/contract.algo.ts:306
    // else if (rMod === Uint64(4)) rightPos = rightPos + Uint64(5)
    dig 11
    pushint 4 // 4
    ==
    bz runMatch_after_if_else@60
    dig 7
    pushint 5 // 5
    +
    bury 8
    b runMatch_after_if_else@60

runMatch_else_body@34:
    // smart_contracts/stupid_racing/contract.algo.ts:296
    // else if (lMod === Uint64(1)) leftPos = leftPos - Uint64(3)
    dig 16
    intc_1 // 1
    ==
    bz runMatch_else_body@36
    dig 13
    pushint 3 // 3
    -
    bury 14
    b runMatch_after_if_else@46

runMatch_else_body@36:
    // smart_contracts/stupid_racing/contract.algo.ts:297
    // else if (lMod === Uint64(2)) leftPos = leftPos - Uint64(1)
    dig 16
    intc_3 // 2
    ==
    bz runMatch_else_body@38
    dig 13
    intc_1 // 1
    -
    bury 14
    b runMatch_after_if_else@46

runMatch_else_body@38:
    // smart_contracts/stupid_racing/contract.algo.ts:298
    // else if (lMod === Uint64(3)) leftPos = leftPos + Uint64(3)
    dig 16
    pushint 3 // 3
    ==
    bz runMatch_else_body@40
    dig 13
    pushint 3 // 3
    +
    bury 14
    b runMatch_after_if_else@46

runMatch_else_body@40:
    // smart_contracts/stupid_racing/contract.algo.ts:299
    // else if (lMod === Uint64(4)) leftPos = leftPos + Uint64(5)
    dig 16
    pushint 4 // 4
    ==
    bz runMatch_after_if_else@46
    dig 13
    pushint 5 // 5
    +
    bury 14
    b runMatch_after_if_else@46

runMatch_after_while@80:
    // smart_contracts/stupid_racing/contract.algo.ts:274
    // let winnerIsLeft = leftWins > rightWins
    dig 12
    dup
    dig 8
    dup
    cover 3
    >
    bury 5
    // smart_contracts/stupid_racing/contract.algo.ts:275
    // if (leftWins === rightWins) {
    ==
    bz runMatch_after_if_else@82
    // smart_contracts/stupid_racing/contract.algo.ts:276
    // const lastByte: uint64 = op.getByte(currentSeed, Uint64(0))
    dig 23
    intc_0 // 0
    getbyte
    // smart_contracts/stupid_racing/contract.algo.ts:277
    // winnerIsLeft = lastByte % Uint64(2) === Uint64(0)
    intc_3 // 2
    %
    !
    bury 3

runMatch_after_if_else@82:
    // smart_contracts/stupid_racing/contract.algo.ts:280
    // return { winnerIsLeft, leftScore: leftWins, rightScore: rightWins }
    pushbytes 0x00
    intc_0 // 0
    dig 4
    setbit
    dig 13
    itob
    concat
    dig 7
    itob
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:243
    // winner: map.winnerIsLeft ? leftWallet : rightWallet,
    dup
    intc_0 // 0
    getbit
    dig 21
    dup
    cover 3
    dig 25
    dup
    cover 4
    uncover 2
    select
    // smart_contracts/stupid_racing/contract.algo.ts:244
    // leftScore: map.leftScore,
    dig 1
    extract 1 8
    // smart_contracts/stupid_racing/contract.algo.ts:245
    // rightScore: map.rightScore,
    uncover 2
    extract 9 8
    // smart_contracts/stupid_racing/contract.algo.ts:240-247
    // const matchResult: MatchResult = {
    //     leftWallet: leftWallet,
    //     rightWallet: rightWallet,
    //     winner: map.winnerIsLeft ? leftWallet : rightWallet,
    //     leftScore: map.leftScore,
    //     rightScore: map.rightScore,
    //     seed: vrfOutput
    // }
    uncover 3
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    dig 19
    dup
    len
    itob
    extract 6 2
    swap
    concat
    swap
    pushbytes 0x0072
    concat
    swap
    concat
    dup
    bury 22
    // smart_contracts/stupid_racing/contract.algo.ts:249
    // this.matchResults(matchId).value = clone(matchResult)
    dig 25
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/stupid_racing/contract.algo.ts:251
    // if (this.state.value === STATE_LOCKED) this.state.value = STATE_RACING
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:251
    // if (this.state.value === STATE_LOCKED) this.state.value = STATE_RACING
    app_global_get_ex
    assert // check GlobalState exists
    intc_3 // 2
    ==
    bz runMatch_after_if_else@11
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:251
    // if (this.state.value === STATE_LOCKED) this.state.value = STATE_RACING
    pushint 3 // 3
    app_global_put

runMatch_after_if_else@11:
    // smart_contracts/stupid_racing/contract.algo.ts:322
    // const size = this.bracketSize.value
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:63
    // bracketSize = GlobalState<uint64>({ key: Bytes`bracket_size` })
    bytec_1 // "bracket_size"
    // smart_contracts/stupid_racing/contract.algo.ts:322
    // const size = this.bracketSize.value
    app_global_get_ex
    swap
    dup
    cover 2
    bury 8
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:323
    // if (size === Uint64(2)) return Uint64(1)
    intc_3 // 2
    ==
    bz runMatch_after_if_else@16
    intc_1 // 1

runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27:
    // smart_contracts/stupid_racing/contract.algo.ts:254
    // if (roundIndex === totalRounds - Uint64(1)) {
    intc_1 // 1
    -
    dig 2
    ==
    bz runMatch_after_if_else@13
    // smart_contracts/stupid_racing/contract.algo.ts:255
    // this.champion.value = matchResult.winner
    dig 20
    extract 64 32
    // smart_contracts/stupid_racing/contract.algo.ts:68
    // champion = GlobalState<AccountType>({ key: Bytes`champion` })
    bytec 11 // "champion"
    // smart_contracts/stupid_racing/contract.algo.ts:255
    // this.champion.value = matchResult.winner
    swap
    app_global_put
    // smart_contracts/stupid_racing/contract.algo.ts:65
    // state = GlobalState<uint64>({ key: Bytes`state` })
    bytec_0 // "state"
    // smart_contracts/stupid_racing/contract.algo.ts:256
    // this.state.value = STATE_COMPLETED
    pushint 4 // 4
    app_global_put

runMatch_after_if_else@13:
    // smart_contracts/stupid_racing/contract.algo.ts:187
    // @abimethod()
    intc_1 // 1
    return

runMatch_after_if_else@16:
    // smart_contracts/stupid_racing/contract.algo.ts:324
    // if (size === Uint64(4)) return Uint64(2)
    dig 5
    pushint 4 // 4
    ==
    bz runMatch_after_if_else@18
    intc_3 // 2
    // smart_contracts/stupid_racing/contract.algo.ts:253
    // const totalRounds: uint64 = this.calculateTotalRounds()
    b runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27

runMatch_after_if_else@18:
    // smart_contracts/stupid_racing/contract.algo.ts:325
    // if (size === Uint64(8)) return Uint64(3)
    dig 5
    intc_2 // 8
    ==
    bz runMatch_after_if_else@20
    pushint 3 // 3
    // smart_contracts/stupid_racing/contract.algo.ts:253
    // const totalRounds: uint64 = this.calculateTotalRounds()
    b runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27

runMatch_after_if_else@20:
    // smart_contracts/stupid_racing/contract.algo.ts:326
    // if (size === Uint64(16)) return Uint64(4)
    dig 5
    pushint 16 // 16
    ==
    bz runMatch_after_if_else@22
    pushint 4 // 4
    // smart_contracts/stupid_racing/contract.algo.ts:253
    // const totalRounds: uint64 = this.calculateTotalRounds()
    b runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27

runMatch_after_if_else@22:
    // smart_contracts/stupid_racing/contract.algo.ts:327
    // if (size === Uint64(32)) return Uint64(5)
    dig 5
    pushint 32 // 32
    ==
    bz runMatch_after_if_else@24
    pushint 5 // 5
    // smart_contracts/stupid_racing/contract.algo.ts:253
    // const totalRounds: uint64 = this.calculateTotalRounds()
    b runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27

runMatch_after_if_else@24:
    // smart_contracts/stupid_racing/contract.algo.ts:328
    // if (size === Uint64(64)) return Uint64(6)
    dig 5
    pushint 64 // 64
    ==
    bz runMatch_after_if_else@26
    pushint 6 // 6
    // smart_contracts/stupid_racing/contract.algo.ts:253
    // const totalRounds: uint64 = this.calculateTotalRounds()
    b runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27

runMatch_after_if_else@26:
    // smart_contracts/stupid_racing/contract.algo.ts:329
    // return Uint64(1)
    intc_1 // 1
    // smart_contracts/stupid_racing/contract.algo.ts:253
    // const totalRounds: uint64 = this.calculateTotalRounds()
    b runMatch_after_inlined_smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.calculateTotalRounds@27

runMatch_else_body@8:
    // smart_contracts/stupid_racing/contract.algo.ts:230
    // const prevRound: uint64 = roundIndex - Uint64(1)
    dig 1
    intc_1 // 1
    -
    // smart_contracts/stupid_racing/contract.algo.ts:231
    // const leftPrevId: uint64 = prevRound * Uint64(100) + matchIndex * Uint64(2)
    pushint 100 // 100
    *
    dig 1
    intc_3 // 2
    *
    +
    // smart_contracts/stupid_racing/contract.algo.ts:232
    // const rightPrevId: uint64 = prevRound * Uint64(100) + matchIndex * Uint64(2) + Uint64(1)
    dup
    intc_1 // 1
    +
    // smart_contracts/stupid_racing/contract.algo.ts:233
    // leftWallet = clone(this.matchResults(leftPrevId).value).winner
    swap
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:71
    // matchResults = BoxMap<uint64, MatchResult>({ keyPrefix: Bytes`m` })
    bytec 6 // "m"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:233
    // leftWallet = clone(this.matchResults(leftPrevId).value).winner
    pushints 64 32 // 64, 32
    box_extract
    bury 23
    // smart_contracts/stupid_racing/contract.algo.ts:234
    // rightWallet = clone(this.matchResults(rightPrevId).value).winner
    itob
    // smart_contracts/stupid_racing/contract.algo.ts:71
    // matchResults = BoxMap<uint64, MatchResult>({ keyPrefix: Bytes`m` })
    bytec 6 // "m"
    swap
    concat
    // smart_contracts/stupid_racing/contract.algo.ts:234
    // rightWallet = clone(this.matchResults(rightPrevId).value).winner
    pushints 64 32 // 64, 32
    box_extract
    bury 20
    b runMatch_after_if_else@9

runMatch_bool_false@4:
    intc_0 // 0
    b runMatch_bool_merge@5


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.getChampion[routing]() -> void:
getChampion:
    // smart_contracts/stupid_racing/contract.algo.ts:334
    // return this.champion.value
    intc_0 // 0
    // smart_contracts/stupid_racing/contract.algo.ts:68
    // champion = GlobalState<AccountType>({ key: Bytes`champion` })
    bytec 11 // "champion"
    // smart_contracts/stupid_racing/contract.algo.ts:334
    // return this.champion.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/stupid_racing/contract.algo.ts:332
    // @abimethod({ readonly: true })
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/stupid_racing/contract.algo.ts::StupidRacingTournament.assertOwnedAllowedAsset(assetId: uint64) -> void:
assertOwnedAllowedAsset:
    // smart_contracts/stupid_racing/contract.algo.ts:361
    // private assertOwnedAllowedAsset(assetId: uint64): void {
    proto 1 0
    pushbytes ""
    // smart_contracts/stupid_racing/contract.algo.ts:362
    // const [balance, holdingExists] = op.AssetHolding.assetBalance(Txn.sender, assetId)
    txn Sender
    frame_dig -1
    asset_holding_get AssetBalance
    // smart_contracts/stupid_racing/contract.algo.ts:363
    // assert(holdingExists && balance > Uint64(0), 'Sender must own each horse asset')
    bz assertOwnedAllowedAsset_bool_false@3
    frame_dig 1
    bz assertOwnedAllowedAsset_bool_false@3
    intc_1 // 1

assertOwnedAllowedAsset_bool_merge@4:
    // smart_contracts/stupid_racing/contract.algo.ts:363
    // assert(holdingExists && balance > Uint64(0), 'Sender must own each horse asset')
    assert // Sender must own each horse asset
    // smart_contracts/stupid_racing/contract.algo.ts:365
    // const [assetTotal, totalExists] = op.AssetParams.assetTotal(assetId)
    frame_dig -1
    asset_params_get AssetTotal
    swap
    frame_bury 0
    // smart_contracts/stupid_racing/contract.algo.ts:366
    // assert(totalExists && assetTotal === Uint64(1), 'Horse asset must be an NFT')
    bz assertOwnedAllowedAsset_bool_false@7
    frame_dig 0
    intc_1 // 1
    ==
    bz assertOwnedAllowedAsset_bool_false@7
    intc_1 // 1

assertOwnedAllowedAsset_bool_merge@8:
    // smart_contracts/stupid_racing/contract.algo.ts:366
    // assert(totalExists && assetTotal === Uint64(1), 'Horse asset must be an NFT')
    assert // Horse asset must be an NFT
    // smart_contracts/stupid_racing/contract.algo.ts:369
    // return
    retsub

assertOwnedAllowedAsset_bool_false@7:
    intc_0 // 0
    b assertOwnedAllowedAsset_bool_merge@8

assertOwnedAllowedAsset_bool_false@3:
    intc_0 // 0
    b assertOwnedAllowedAsset_bool_merge@4
